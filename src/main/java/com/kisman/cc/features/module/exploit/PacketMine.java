package com.kisman.cc.features.module.exploit;

import com.kisman.cc.Kisman;
import com.kisman.cc.event.events.EventDamageBlock;
import com.kisman.cc.event.events.EventPlayerMove;
import com.kisman.cc.features.module.Category;
import com.kisman.cc.features.module.Module;
import com.kisman.cc.settings.Setting;
import com.kisman.cc.settings.types.SettingGroup;
import com.kisman.cc.settings.util.RenderingRewritePattern;
import com.kisman.cc.settings.util.ScalingPattern;
import com.kisman.cc.util.TimerUtils;
import com.kisman.cc.util.entity.player.InventoryUtil;
import com.kisman.cc.util.math.MathUtil;
import com.kisman.cc.util.world.BlockUtil;
import com.kisman.cc.util.world.BlockUtil2;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.BlockLiquid;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class PacketMine extends Module {
    private final Setting speed = register(new Setting("Speed", this, 0.8f, 0.1f, 1, false));
    public Setting instant = register(new Setting("Instant", this, true));
    private final Setting silent = register(new Setting("Silent", this, true));
    private final Setting strict = register(new Setting("Strict", this, false));
    private final Setting autoSwitch = register(new Setting("Auto Switch", this, true));
    private final SettingGroup renderGroup = register(new SettingGroup(new Setting("Render", this)));
    private final RenderingRewritePattern renderer = new RenderingRewritePattern(this).group(renderGroup).preInit().init();
    private final Setting inverse = register(renderGroup.add(new Setting("Inverse", this, false)));
    private final ScalingPattern scalier = new ScalingPattern(this).group(renderGroup).preInit().init();
    private final Setting instantAttempts = register(new Setting("Instant Attempts", this, 8, 0, 20, true));
    private final Setting range = register(new Setting("Range", this, 16, 4, 30, true));
    private final  Setting packetSpam = register(new Setting("Packet Spam", this, 1, 1, 10, true));

    public static PacketMine instance;

    private BlockPos currentPos;
    private final TimerUtils timer = new TimerUtils();
    private long start;
    private int oldSlot, delay, rebreakCount;
    private boolean swap = false, checked, strictCheck;

    public PacketMine() {
        super("PacketMine", "PacketMine", Category.EXPLOIT);

        instance = this;
    }

    public void onEnable() {
        super.onEnable();
        Kisman.EVENT_BUS.subscribe(listener);
        Kisman.EVENT_BUS.subscribe(dmg);
        rebreakCount = 0;
        oldSlot = -1;
        currentPos = null;
        delay = 0;
    }

    public void onDisable() {
        super.onDisable();
        Kisman.EVENT_BUS.unsubscribe(listener);
        Kisman.EVENT_BUS.unsubscribe(dmg);
    }

    public void update() {
        if(mc.player == null || mc.world == null) return;

        if (swap) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
            if (delay >= 2) {
                InventoryUtil.switchToSlot(oldSlot, false);
                swap = false;
                if (!instant.getValBoolean() && currentPos != null) currentPos = null;
                delay = 0;
            }
            delay++;
        }
    }

    @EventHandler
    private final Listener<EventDamageBlock> dmg = new Listener<>(event -> {
        if (swap) {
            event.cancel();
            return;
        }

        if (!BlockUtil.canBlockBeBroken(event.getBlockPos())) return;
        if (currentPos != null) {
            if (event.getBlockPos().toLong() == currentPos.toLong()) {
                if (!swap && getBlockProgress(currentPos, mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(currentPos)), start) <= 1 - speed.getValDouble() && mc.world.getBlockState(currentPos).getBlock() != Blocks.AIR) {
                    if (silent.getValBoolean()) swapTo();
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
                    event.cancel();
                }
                return;
            }

            if (event.getBlockPos().toLong() != currentPos.toLong()) {
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, currentPos, event.getFaceDirection()));
                mc.playerController.isHittingBlock = false;
            }
        }

        mc.player.connection.sendPacket(new CPacketAnimation(EnumHand.MAIN_HAND));
        for (int j = 0; j < packetSpam.getValInt(); j++) mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getFaceDirection()));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), EnumFacing.DOWN));
        currentPos = event.getBlockPos();
        start = System.currentTimeMillis();
        strictCheck = true;
        timer.reset();
        event.cancel();
    });

    @EventHandler
    private final Listener<EventPlayerMove> listener = new Listener<>(event -> {
        if (currentPos != null) {
            if (instant.getValBoolean()) {
                if (mc.world.getBlockState(currentPos).getBlock() == Blocks.AIR) {
                    if (!checked) {
                        rebreakCount = 0;
                        checked = true;
                        start = System.currentTimeMillis();
                        timer.reset();
                        strictCheck = false;
                    }
                } else {
                    if (strict.getValBoolean() && !strictCheck) {
                        Block block = mc.world.getBlockState(currentPos).getBlock();
                        if (!(block.equals(Blocks.ENDER_CHEST) || block.equals(Blocks.ANVIL) || block.equals(Blocks.AIR))) {
                            rebreakCount = 0;
                            currentPos = null;
                            timer.reset();
                            strictCheck = true;
                            return;
                        }
                    }
                    checked = false;
                }
            }

            if (getBlockProgress(currentPos, mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(currentPos)), start) <= 1 - speed.getValDouble() && mc.world.getBlockState(currentPos).getBlock() != Blocks.AIR) if (autoSwitch.getValBoolean()) if(!swapTo()) return;
            if (!swap) oldSlot = mc.player.inventory.currentItem;
            if (currentPos != null && mc.player.getDistanceSq(currentPos) >= MathUtil.square(range.getValInt())) currentPos = null;
        }
        try {mc.playerController.blockHitDelay = 0;} catch (Exception ignored) {}
    });

    private float getBlockProgress(BlockPos blockPos, ItemStack stack, long start) {
        return (float) MathUtil.clamp(1 - ((System.currentTimeMillis() - start) / (double) InventoryUtil.time(blockPos, stack)), 0, 1);
    }

    private boolean swapTo() {
        if (rebreakCount > instantAttempts.getValInt() - 1 && instantAttempts.getValInt() != 0) {
            currentPos = null;
            rebreakCount = 0;
            return false;
        }
        InventoryUtil.switchToSlot(InventoryUtil.findBestToolSlot(currentPos), false);
        if (silent.getValBoolean()) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
            rebreakCount++;
            if (!instant.getValBoolean()) currentPos = null;
            InventoryUtil.switchToSlot(oldSlot, false);
        } else swap = true;
        return true;
    }

    @SubscribeEvent
    public void onRenderWorld(RenderWorldLastEvent event) {
        if (!(currentPos == null || mc.world.getBlockState(currentPos).getBlock() == Blocks.AIR || mc.world.getBlockState(currentPos).getBlock() instanceof BlockLiquid)) renderer.draw(BlockUtil2.getMutableProgressBB2(currentPos, mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(currentPos)), start, scalier, inverse.getValBoolean()));
    }
}
