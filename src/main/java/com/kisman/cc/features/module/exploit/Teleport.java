package com.kisman.cc.features.module.exploit;

import com.kisman.cc.features.module.Category;
import com.kisman.cc.features.module.Module;
import com.kisman.cc.features.module.ModuleInfo;
import com.kisman.cc.features.subsystem.subsystems.EnemyManagerKt;
import com.kisman.cc.settings.Setting;
import com.kisman.cc.settings.types.number.NumberType;
import com.kisman.cc.util.chat.cubic.ChatUtility;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.CPacketPlayer;
import org.lwjgl.input.Keyboard;

/**
 * -Invented by TuxISCool
 * -Worked out by zPrestige_
 */
@ModuleInfo(
        name = "Teleport",
        desc = "5b5t teleport exploit by zPrestige_",
        category = Category.EXPLOIT
)
public class Teleport extends Module {
    private final Setting force = register(new Setting("Force", this, 1, 0.1f, 10, false));
    private final Setting attempts = register(new Setting("Attempts", this, 10, 1, 20, true));
    private final Setting distance = register(new Setting("Distance", this, 5, 1, 50, true));
    private final Setting enemyTpKey = register(new Setting("Enemy Tp Key", this, Keyboard.KEY_NONE));
    private final Setting oneBlockKey = register(new Setting("One BlockKey", this, Keyboard.KEY_NONE));
    private final Setting hold = register(new Setting("Hold", this, false));
    private final Setting airGlide = register(new Setting("Air Glide", this, false));
    private final Setting verticalGlideSpeed = register(new Setting("Vertical Glide Speed", this, 1, 0.1f, 100, NumberType.PERCENT));

    private boolean executed;

    public void update() {
        if(mc.player == null || mc.world == null) return;

        if(enemyTpKey.getKey() != Keyboard.KEY_NONE) {
            if(Keyboard.isKeyDown(enemyTpKey.getKey())) {
                EntityPlayer target = EnemyManagerKt.nearest();
                if(target == null) ChatUtility.error().printClientModuleMessage("No target found unable to teleport((");
                else {
                    for (int i = 0; i < attempts.getValInt(); ++i) {
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValFloat() / 10), mc.player.posZ, false));
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(target.posX, target.posY, target.posZ, true));
                    }
                }
                return;
            }
        }

        if(airGlide.getValBoolean()) {
            mc.player.motionY = -0.01;
            double currY = mc.player.posY;
            if(mc.gameSettings.keyBindJump.isKeyDown()) for(int i = 0; i < attempts.getValInt(); ++i) mc.player.setPosition(mc.player.posX, currY + verticalGlideSpeed.getValFloat() / 100f, mc.player.posZ);
            if(mc.gameSettings.keyBindSneak.isKeyDown()) for(int i = 0; i < attempts.getValInt(); ++i) mc.player.setPosition(mc.player.posX, currY - verticalGlideSpeed.getValFloat() / 100f, mc.player.posZ);
        }

        if(oneBlockKey.getKey() != Keyboard.KEY_NONE) {
            if(Keyboard.isKeyDown(oneBlockKey.getKey())) {
                for(int i = 0; i < attempts.getValInt(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValFloat() / 10), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -1);
                            break;
                        case EAST:
                            sendPacket(1, 0, 0);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, 1);
                            break;
                        case WEST:
                            sendPacket(-1, 0, 0);
                            break;
                    }
                }
            }
        }

        if(mc.gameSettings.keyBindAttack.isKeyDown()) {
            if(!executed || hold.getValBoolean()) {
                for(int i = 0; i < attempts.getValInt(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValFloat() / 10), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -distance.getValInt());
                            break;
                        case EAST:
                            sendPacket(distance.getValInt(), 0, 0);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, distance.getValInt());
                            break;
                        case WEST:
                            sendPacket(-distance.getValInt(), 0, 0);
                            break;
                    }
                    executed = true;
                }
            }
        } else executed = false;
    }

    private void sendPacket(double x, double y, double z) {
        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + x, mc.player.posY + y, mc.player.posZ + z, true));
    }
}
