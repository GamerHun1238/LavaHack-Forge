package com.kisman.cc.features.module.exploit;

import com.kisman.cc.features.module.Category;
import com.kisman.cc.features.module.Module;
import com.kisman.cc.settings.Setting;
import com.kisman.cc.util.TimerUtils;
import com.kisman.cc.util.chat.cubic.ChatUtility;
import com.kisman.cc.util.entity.player.PlayerUtil;
import com.kisman.cc.util.movement.MotionUtil;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.BlockPos;

public class TickShiftTeleport extends Module {
    private final Setting test = register(new Setting("Test", this, false));
    private final Setting strict = register(new Setting("Strict", this, true));
    private final Setting delayMultiplier = register(new Setting("DelayMultiplier", this, 1.0, 0.0, 10.0, false));
    private final Setting sprint = register(new Setting("Sprint", this, false));
    private final Setting setPos = register(new Setting("SetPosition", this, false));
    private final Setting smartOnGround = register(new Setting("SmartOnGround", this, false));
    private final Setting noClip = register(new Setting("NoClip", this, false));
    private final Setting cancelInBlock = register(new Setting("CancelInBlock", this, false));
    private final Setting cancelOffGround = register(new Setting("CancelOffGround", this, false));

    public TickShiftTeleport(){
        super("TickShiftTeleport", Category.EXPLOIT);
    }

    private final TimerUtils timer = new TimerUtils();
    private CPacketPlayer.Position[] movementPackets = new CPacketPlayer.Position[0];
    private long delay;

    @Override
    public void onEnable(){
        if(mc.player == null || mc.world == null){
            toggle();
            return;
        }
        BlockPos pos = mc.objectMouseOver.getBlockPos();
        // pos should be only null if the players object mouse over is on an entity
        // and only then it should be null - Cubic
        if(pos == null || mc.objectMouseOver.entityHit != null) {
            ChatUtility.error().printClientModuleMessage("Cannot Teleport onto an Entity!");
            return;
        }
        pos = pos.up();
        double x = pos.getX();
        double y = pos.getY();
        double z = pos.getZ();
        if (test.getValBoolean()) {
            y = PlayerUtil.GetLocalPlayerPosFloored().getY();
        }
        x += 0.5;
        z += 0.5;
        double pX = mc.player.posX;
        double pY = mc.player.posY;
        double pZ = mc.player.posZ;
        int ticks = MotionUtil.getTicksUntil(mc.player.getDistance(x, y, z), sprint.getValBoolean());
        movementPackets = MotionUtil.getPacketsTeleport(ticks, true, cancelInBlock.getValBoolean(), cancelOffGround.getValBoolean(), smartOnGround.getValBoolean(), pX, pY, pZ, x, y, z);
        timer.reset();
        delay = (long) (ticks * 50L * delayMultiplier.getValDouble());
    }

    @Override
    public void update(){
        if(mc.player == null || mc.world == null){
            toggle();
            return;
        }

        if(strict.getValBoolean() && !timer.passedMillis(delay))
            return;

        ChatUtility.info().printClientModuleMessage("Charged!");
        ChatUtility.info().printClientModuleMessage("Teleporting...");

        boolean noClip = mc.player.noClip;

        if(this.noClip.getValBoolean())
            mc.player.noClip = true;

        for(CPacketPlayer.Position packet : movementPackets){
            if(packet == null)
                continue;
            mc.player.connection.sendPacket(packet);
            if(setPos.getValBoolean())
                mc.player.setPosition(packet.x, packet.y, packet.z);
        }

        if(movementPackets.length > 0) {
            CPacketPlayer.Position lastPacket = movementPackets[movementPackets.length - 1];
            mc.player.setPosition(lastPacket.x, lastPacket.y, lastPacket.z);
        }

        mc.player.noClip = noClip;

        toggle();

    }

    @Override
    public void onDisable(){
        timer.reset();
        movementPackets = new CPacketPlayer.Position[0];
        delay = -1;
    }
}
