package com.kisman.cc.features.module.exploit

import com.kisman.cc.Kisman
import com.kisman.cc.event.events.EventDamageBlock
import com.kisman.cc.features.module.Category
import com.kisman.cc.features.module.ModuleInfo
import com.kisman.cc.features.module.ShaderableModule
import com.kisman.cc.features.module.WorkInProgress
import com.kisman.cc.features.subsystem.subsystems.RotationSystem
import com.kisman.cc.settings.Setting
import com.kisman.cc.settings.types.SettingGroup
import com.kisman.cc.settings.util.EasingsPattern
import com.kisman.cc.settings.util.SlideRenderingRewritePattern
import com.kisman.cc.util.entity.player.InventoryUtil
import com.kisman.cc.util.enums.dynamic.SwapEnum2
import com.kisman.cc.util.render.pattern.SlideRendererPattern
import com.kisman.cc.util.world.BlockUtil
import com.kisman.cc.util.world.BlockUtil2
import me.zero.alpine.listener.EventHook
import me.zero.alpine.listener.Listener
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.CPacketPlayerDigging
import net.minecraft.util.EnumFacing
import net.minecraft.util.EnumHand
import net.minecraft.util.math.AxisAlignedBB
import net.minecraft.util.math.BlockPos
import net.minecraftforge.client.event.RenderWorldLastEvent
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent

/**
 * @author _kisman_
 * @since 20:22 of 12.02.2023
 */
@WorkInProgress
@ModuleInfo(
    name = "PacketMineRewrite3",
    desc = "pakt mine",
    category = Category.EXPLOIT
)
class PacketMineRewrite3 : ShaderableModule() {
    private val await = register(Setting("Await", this, false))
    private val swing = register(Setting("Swing", this, true))
    private val swap = register(Setting("Swap", this, true))
    private val silent = register(Setting("Silent", this, true))
    private val rotate = register(Setting("Rotate", this, false))
    private val abort = register(Setting("Abort", this, false))
    private val stopActiveHand = register(Setting("Stop Active Hand", this, false))
    private val strict = register(Setting("Strict", this, false))

    private val rendererGroup = register(SettingGroup(Setting("Renderer", this)))
    private val pattern = SlideRenderingRewritePattern(this).group(rendererGroup).preInit().init()
    private val easing = EasingsPattern(this).group(rendererGroup).preInit().init()

    private val renderer = SlideRendererPattern()

    private var pos : BlockPos? = null
    private var facing : EnumFacing? = null
    private var start = 0L

    /*init {
        displayName = "PacketMine"
    }*/

    override fun onEnable() {
        super.onEnable()
        Kisman.EVENT_BUS.subscribe(clickBlock)

        reset()
        start = 0L
    }

    override fun onDisable() {
        super.onDisable()
        Kisman.EVENT_BUS.unsubscribe(clickBlock)
    }

    override fun update() {
        setDisplayInfo { if(pos == null) "[no block no fun]" else "[${pos!!.x} ${pos!!.y} ${pos!!.z}]" }

        if(mc.player == null || mc.world == null) {
            return
        }

        mc.playerController.blockHitDelay = 0

        if(pos == null) {
            return
        }

        val block = mc.world.getBlockState(pos!!).block

        /*fun swap(
            slot : Int
        ) {
            if(strict.valBoolean && mc.currentScreen == null) {
                InventoryUtil.inventorySwap(slot)
            } else {
                SwapEnum2.Swap.Packet.task.doTask(slot, false)
            }
        }*/

        if(block != Blocks.AIR) {
//            val oldSlot = mc.player.inventory.currentItem
//            val toolSlot = InventoryUtil.findBestToolSlot(pos)
//            val shouldSwap = swap.valBoolean && oldSlot != toolSlot && toolSlot != -1

            if(rotate.valBoolean) {
                RotationSystem.handleRotate(pos!!)
            }

            if(stopActiveHand.valBoolean) {
                mc.player.stopActiveHand()
            }

            /*if(shouldSwap) {
                swap(toolSlot)
            }*/

            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos!!, facing!!))

            if(abort.valBoolean) {
                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, pos!!, EnumFacing.UP))
            }

            /*if(silent.valBoolean && shouldSwap) {
                swap(oldSlot)
            }*/
        } else {
            //TODO: instant
            reset()
        }
    }

    private fun reset() {
        pos = null
        facing = null
    }

    private val clickBlock = Listener<EventDamageBlock>(EventHook {
        if(await.valBoolean && pos != null && mc.world.getBlockState(pos!!).block != Blocks.AIR) {
            return@EventHook
        }

        if(BlockUtil.canBlockBeBroken(it.blockPos)) {
            fun swap(
                slot : Int
            ) {
                if(strict.valBoolean && mc.currentScreen == null) {
                    InventoryUtil.inventorySwap(slot)
                } else {
                    SwapEnum2.Swap.Packet.task.doTask(slot, false)
                }
            }

            pos = it.blockPos
            facing = it.faceDirection
            start = System.currentTimeMillis()

            val oldSlot = mc.player.inventory.currentItem
            val toolSlot = InventoryUtil.findBestToolSlot(pos)
            val shouldSwap = swap.valBoolean && oldSlot != toolSlot && toolSlot != -1

            if(shouldSwap) {
                swap(toolSlot)
            }

            if(swing.valBoolean) {
                mc.player.swingArm(EnumHand.MAIN_HAND)
            }

            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos!!, facing!!))
            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos!!, facing!!))

            if(silent.valBoolean && shouldSwap) {
                swap(oldSlot)
            }
        }
    })

    @SubscribeEvent
    fun onRenderWorld(
        event : RenderWorldLastEvent
    ) {
        handleDraw(pattern)
    }

    override fun draw() {
        fun offset(
            aabb : AxisAlignedBB
        ) : AxisAlignedBB = AxisAlignedBB(
            aabb.minX + 0.5,
            aabb.minY + 0.5,
            aabb.minZ + 0.5,
            aabb.maxX - 0.5,
            aabb.maxY - 0.5,
            aabb.maxZ - 0.5
        )

        renderer.handleRenderWorld(
            pattern,
            { it0 ->
                if(pos != null) {
                    offset(easing.mutateBB(
                        it0,
                        BlockUtil2.getBreakingProgress(
                            pos,
                            mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(pos)),
                            start
                        )
                    ))
                } else {
                    it0
                }
            },
            pos,
            null
        )
    }
}