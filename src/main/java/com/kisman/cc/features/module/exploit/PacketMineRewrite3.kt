package com.kisman.cc.features.module.exploit

import com.kisman.cc.Kisman
import com.kisman.cc.event.events.EventDamageBlock
import com.kisman.cc.event.events.PacketEvent
import com.kisman.cc.features.module.Category
import com.kisman.cc.features.module.ModuleInfo
import com.kisman.cc.features.module.ShaderableModule
import com.kisman.cc.features.module.combat.autorer.modules.Crystals
import com.kisman.cc.features.subsystem.subsystems.RotationSystem
import com.kisman.cc.settings.Setting
import com.kisman.cc.settings.types.SettingGroup
import com.kisman.cc.settings.util.EasingsPattern
import com.kisman.cc.settings.util.SlideRenderingRewritePattern
import com.kisman.cc.util.block
import com.kisman.cc.util.entity.player.InventoryUtil
import com.kisman.cc.util.enums.dynamic.SwapEnum2
import com.kisman.cc.util.render.pattern.SlideRendererPattern
import com.kisman.cc.util.world.BlockUtil
import com.kisman.cc.util.world.BlockUtil2
import me.zero.alpine.listener.EventHook
import me.zero.alpine.listener.Listener
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.CPacketHeldItemChange
import net.minecraft.network.play.client.CPacketPlayerDigging
import net.minecraft.util.EnumFacing
import net.minecraft.util.EnumHand
import net.minecraft.util.math.AxisAlignedBB
import net.minecraft.util.math.BlockPos
import net.minecraftforge.client.event.RenderWorldLastEvent
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent

/**
 * @author _kisman_
 * @since 20:22 of 12.02.2023
 */
@Suppress("UNUSED_PARAMETER")
@ModuleInfo(
    name = "PacketMineRewrite3",
    display = "PacketMine",
    desc = "pakt mine",
    category = Category.EXPLOIT
)
class PacketMineRewrite3 : ShaderableModule() {
    private val await = register(Setting("Await", this, false))
    private val swing = register(Setting("Swing", this, true))
    private val swap = register(Setting("Swap", this, true))
    private val fast = register(Setting("Fast", this, false))
    private val silent = register(Setting("Silent", this, true))
    private val rotate = register(Setting("Rotate", this, false))
    private val strict = register(Setting("Strict", this, false))

    private val crystalsGroup = register(SettingGroup(Setting("Crystals", this)))
    private val crystalsState = register(crystalsGroup.add(Setting("Crystals State", this, false).setTitle("State")))
    private val crystalsStartAfter = register(crystalsGroup.add(Setting("Crystals Starts After", this, 0.95, 0.0, 1.0, false).setTitle("Starts After")))

    private val rendererGroup = register(SettingGroup(Setting("Renderer", this)))
    private val pattern = SlideRenderingRewritePattern(this).group(rendererGroup).preInit().init()
    private val easing = EasingsPattern(this).group(rendererGroup).preInit().init()

    private val renderer = SlideRendererPattern()

    private var pos : BlockPos? = null
    private var facing : EnumFacing? = null
    private var start = 0L
    private var breaks = 0

    init {
        setDisplayInfo { if(pos == null) "[no block no fun]" else "[${pos!!.x} ${pos!!.y} ${pos!!.z}]" }
    }

    override fun onEnable() {
        super.onEnable()
        Kisman.EVENT_BUS.subscribe(clickBlock)
        Kisman.EVENT_BUS.subscribe(send)

        reset()
    }

    override fun onDisable() {
        super.onDisable()
        Kisman.EVENT_BUS.unsubscribe(clickBlock)
        Kisman.EVENT_BUS.unsubscribe(send)
    }

    override fun update() {
        if(mc.player == null || mc.world == null) {
            return
        }

        if(pos == null || block(pos!!) == Blocks.AIR || breaks > 2) {
            reset()
            return
        }

        val slot = InventoryUtil.findBestToolSlot(pos)
        val progress = 1 - BlockUtil2.getBreakingProgress(pos, mc.player.inventory.getStackInSlot(slot), start)

        fun swap(
            slot : Int
        ) {
            if(strict.valBoolean) {
                if(mc.currentScreen == null) {
                    InventoryUtil.inventorySwap(slot)
                }
            } else {
                SwapEnum2.Swap.Packet.task.doTask(slot, false)
            }
        }

        if(crystalsState.valBoolean && progress > crystalsStartAfter.valDouble) {
            Crystals.instance!!.pos = pos!!
        }

        if(progress > 0.95) {
            if(rotate.valBoolean) {
                RotationSystem.handleRotate(pos!!)
            }
        }

        if(progress >= 1) {
            val oldSlot = mc.player.inventory.currentItem

            if(swap.valBoolean) {
                swap(slot)
            }

            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos!!, facing!!))
            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, pos!!, EnumFacing.UP))

            if(fast.valBoolean) {
                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos!!, facing!!))
            }

            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos!!, facing!!))

            if(swap.valBoolean && silent.valBoolean) {
                swap(
                    if(strict.valBoolean) {
                        slot
                    } else {
                        oldSlot
                    }
                )
            }

            breaks++
        }
    }

    private fun reset() {
        pos = null
        facing = null
        start = 0L
        breaks = 0

        if(crystalsState.valBoolean) {
            Crystals.instance!!.pos = null
        }
    }

    private val clickBlock = Listener<EventDamageBlock>(EventHook {
        if(await.valBoolean && pos != null && mc.world.getBlockState(pos!!).block != Blocks.AIR) {
            return@EventHook
        }

        if(BlockUtil.canBlockBeBroken(it.blockPos)) {
            pos = it.blockPos
            facing = it.faceDirection
            start = System.currentTimeMillis()

            if(swing.valBoolean) {
                mc.player.swingArm(EnumHand.MAIN_HAND)
            }

            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos!!, facing!!))
            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos!!, EnumFacing.UP))
        }
    })

    private val send = Listener<PacketEvent.Send>(EventHook {
        val packet = it.packet

        if(packet is CPacketHeldItemChange && strict.valBoolean) {
            reset()
        }
    })

    @SubscribeEvent
    fun onRenderWorld(
        event : RenderWorldLastEvent
    ) {
        handleDraw(pattern)
    }

    override fun draw() {
        fun offset(
            aabb : AxisAlignedBB
        ) : AxisAlignedBB = AxisAlignedBB(
            aabb.minX + 0.5,
            aabb.minY + 0.5,
            aabb.minZ + 0.5,
            aabb.maxX - 0.5,
            aabb.maxY - 0.5,
            aabb.maxZ - 0.5
        )

        renderer.handleRenderWorld(
            pattern,
            { it0 ->
                if(pos != null) {
                    offset(easing.mutateBB(
                        it0,
                        1 - BlockUtil2.getBreakingProgress(
                            pos,
                            mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(pos)),
                            start
                        )
                    ))
                } else {
                    it0
                }
            },
            pos,
            null
        )
    }
}