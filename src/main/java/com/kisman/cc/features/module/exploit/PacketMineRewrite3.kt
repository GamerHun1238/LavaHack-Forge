package com.kisman.cc.features.module.exploit

import com.kisman.cc.Kisman
import com.kisman.cc.event.events.EventDamageBlock
import com.kisman.cc.event.events.PacketEvent
import com.kisman.cc.features.module.Category
import com.kisman.cc.features.module.ModuleInfo
import com.kisman.cc.features.module.ShaderableModule
import com.kisman.cc.features.module.combat.autorer.modules.Crystals
import com.kisman.cc.features.subsystem.subsystems.RotationSystem
import com.kisman.cc.settings.Setting
import com.kisman.cc.settings.types.SettingEnum
import com.kisman.cc.settings.types.SettingGroup
import com.kisman.cc.settings.util.EasingsPattern
import com.kisman.cc.settings.util.RenderingRewritePattern
import com.kisman.cc.util.block
import com.kisman.cc.util.entity.player.InventoryUtil
import com.kisman.cc.util.enums.AABBProgressModifiers
import com.kisman.cc.util.enums.dynamic.SwapEnum2
import com.kisman.cc.util.render.pattern.SlideRendererPattern
import com.kisman.cc.util.world.BlockUtil2
import me.zero.alpine.listener.EventHook
import me.zero.alpine.listener.Listener
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.CPacketHeldItemChange
import net.minecraft.network.play.client.CPacketPlayerDigging
import net.minecraft.util.EnumFacing
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.client.event.RenderWorldLastEvent
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent

/**
 * @author _kisman_
 * @since 20:22 of 12.02.2023
 */
@Suppress("UNUSED_PARAMETER")
@ModuleInfo(
    name = "PacketMineRewrite3",
    display = "PacketMine",
    desc = "pakt mine",
    category = Category.EXPLOIT
)
class PacketMineRewrite3 : ShaderableModule() {
    private val await = register(Setting("Await", this, false))
    private val swing = register(Setting("Swing", this, true))
    private val swap = register(Setting("Swap", this, true))
    private val fast = register(Setting("Fast", this, false))
    private val silent = register(Setting("Silent", this, true))
    private val rotate = register(Setting("Rotate", this, false))
    private val strict = register(Setting("Strict", this, false))

    private val multibreak = register(Setting("Multi Break", this, false))

    private val crystalsGroup = register(SettingGroup(Setting("Crystals", this)))
    private val crystalsState = register(crystalsGroup.add(Setting("Crystals State", this, false).setTitle("State")))
    private val crystalsStartAfter = register(crystalsGroup.add(Setting("Crystals Starts After", this, 0.95, 0.0, 1.0, false).setTitle("Starts After")))

    private val rendererGroup = register(SettingGroup(Setting("Renderer", this)))
    private val logic = register(rendererGroup.add(SettingEnum("Logic", this, AABBProgressModifiers.CentredBox)))
    private val pattern = RenderingRewritePattern(this).group(rendererGroup).preInit().init()
    private val easing = EasingsPattern(this).group(rendererGroup).preInit().init()

    private val renderer = SlideRendererPattern()

    private var pos : BlockPos? = null
    private var facing : EnumFacing? = null
    private var start = 0L
    private var breaks = 0

    private val queue = mutableMapOf<BlockPos, Triple<Int, Long, EnumFacing>>()

    init {
        setDisplayInfo { "[${if(pos == null) "no block no fun" else "${pos!!.x} ${pos!!.y} ${pos!!.z}${if (queue.isEmpty()) "" else " | Queue: ${queue.size}"}"}]" }

        instance = this
    }

    companion object {
        @JvmField var instance : PacketMineRewrite3? = null
    }

    override fun onEnable() {
        super.onEnable()
        Kisman.EVENT_BUS.subscribe(clickBlock)
        Kisman.EVENT_BUS.subscribe(send)

        reset()
    }

    override fun onDisable() {
        super.onDisable()
        Kisman.EVENT_BUS.unsubscribe(clickBlock)
        Kisman.EVENT_BUS.unsubscribe(send)
    }

    override fun update() {
        if(mc.player == null || mc.world == null) {
            return
        }

        if(pos == null || block(pos!!) == Blocks.AIR || breaks > 2) {
            reset()
            return
        }

        if(!multibreak.valBoolean && queue.isNotEmpty()) {
            queue.clear()
        }

        fun progress(
            pos : BlockPos,
            slot : Int
        ) : Double = 1 - BlockUtil2.getBreakingProgress(pos, mc.player.inventory.getStackInSlot(slot), start)

        val slot = InventoryUtil.findBestToolSlot(pos)
        val progress = progress(pos!!, slot)

        fun swap(
            slot : Int
        ) {
            if(strict.valBoolean) {
                if(mc.currentScreen == null) {
                    InventoryUtil.inventorySwap(slot)
                }
            } else {
                SwapEnum2.Swap.Packet.task.doTask(slot, false)
            }
        }

        if(crystalsState.valBoolean && progress > crystalsStartAfter.valDouble) {
            Crystals.instance!!.pos = pos!!
        }

        fun processBlock(
            pos : BlockPos,
            triple : Triple<Int, Long, EnumFacing>,
            progress : Double
        ) : Int {
            if (progress > 0.95) {
                if (rotate.valBoolean) {
                    RotationSystem.handleRotate(pos)
                }
            }

            return if (progress >= 1) {
                val oldSlot = mc.player.inventory.currentItem

                if (swap.valBoolean) {
                    swap(slot)
                }

                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, triple.third))
                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, pos, EnumFacing.UP))

                if (fast.valBoolean) {
                    mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, triple.third))
                }

                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, triple.third))

                if (swap.valBoolean && silent.valBoolean) {
                    swap(
                        if (strict.valBoolean) {
                            slot
                        } else {
                            oldSlot
                        }
                    )
                }

                triple.first + 1
            } else {
                triple.first
            }
        }

        breaks = processBlock(pos!!, Triple(breaks, start, facing!!), progress)

        for(entry in HashMap(queue)) {
            val pos = entry.key
            val triple = entry.value

            if(triple.first <= 2) {
                val progress0 = progress(pos, slot)

                queue[pos] = Triple(processBlock(pos, triple, progress0), triple.second, triple.third)
            } else {
                queue.remove(pos)
            }
        }
    }

    private fun reset() {
        pos = null
        facing = null
        start = 0L
        breaks = 0

        if(crystalsState.valBoolean) {
            Crystals.instance!!.pos = null
        }
    }

    private val clickBlock = Listener<EventDamageBlock>(EventHook {
        if(await.valBoolean && pos != null && mc.world.getBlockState(pos!!).block != Blocks.AIR) {
            return@EventHook
        }

        if(BlockUtil2.canBlockBeBroken(it.blockPos)) {
            if(pos != null && multibreak.valBoolean) {
                queue[pos!!] = Triple(breaks, start, facing!!)
            }

            pos = it.blockPos
            facing = it.faceDirection
            start = System.currentTimeMillis()

            if(swing.valBoolean) {
                mc.player.swingArm(EnumHand.MAIN_HAND)
            }

            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos!!, facing!!))
            mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos!!, EnumFacing.UP))
        }
    })

    private val send = Listener<PacketEvent.Send>(EventHook {
        val packet = it.packet

        if(packet is CPacketHeldItemChange && strict.valBoolean) {
            reset()
        }
    })

    @SubscribeEvent
    fun onRenderWorld(
        event : RenderWorldLastEvent
    ) {
        handleDraw(pattern)
    }

    override fun draw() {
        fun processBlock(
            pos : BlockPos?,
            start : Long
        ) {
            renderer.handleRenderWorld(
                0f,
                0f,
                0f,
                pattern,
                { it0 ->
                    if (pos != null) {
                        logic.valEnum.modifier.modify(
                            it0,
                            easing.mutateProgress(
                                1 - BlockUtil2.getBreakingProgress(
                                    pos,
                                    mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(pos)),
                                    start
                                )
                            )
                        )
                    } else {
                        it0
                    }
                },
                pos,
                null
            )
        }

        if(pos != null) {
            processBlock(pos, start)
        }

        for(entry in queue) {
            val pos = entry.key
            val triple = entry.value
            val start = triple.second

            processBlock(pos, start)
        }
    }

    fun current() : BlockPos? = pos
    fun queue() : Set<BlockPos> = queue.keys
}