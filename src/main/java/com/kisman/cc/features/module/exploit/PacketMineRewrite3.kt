package com.kisman.cc.features.module.exploit

import com.kisman.cc.Kisman
import com.kisman.cc.event.events.EventDamageBlock
import com.kisman.cc.event.events.PacketEvent
import com.kisman.cc.features.module.Category
import com.kisman.cc.features.module.ModuleInfo
import com.kisman.cc.features.module.ShaderableModule
import com.kisman.cc.features.module.combat.autorer.modules.Crystals
import com.kisman.cc.features.subsystem.subsystems.RotationSystem
import com.kisman.cc.settings.Setting
import com.kisman.cc.settings.SettingsList
import com.kisman.cc.settings.types.SettingEnum
import com.kisman.cc.settings.types.SettingGroup
import com.kisman.cc.settings.util.EasingsPattern
import com.kisman.cc.settings.util.RenderingRewritePattern
import com.kisman.cc.util.block
import com.kisman.cc.util.chat.cubic.ChatUtility
import com.kisman.cc.util.client.collections.Quad
import com.kisman.cc.util.entity.player.InventoryUtil
import com.kisman.cc.util.enums.AABBProgressModifiers
import com.kisman.cc.util.enums.dynamic.SwapEnum2
import com.kisman.cc.util.render.pattern.SlideRendererPattern
import com.kisman.cc.util.world.BlockUtil2
import me.zero.alpine.listener.EventHook
import me.zero.alpine.listener.Listener
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.CPacketHeldItemChange
import net.minecraft.network.play.client.CPacketPlayerDigging
import net.minecraft.util.EnumFacing
import net.minecraft.util.EnumHand
import net.minecraft.util.math.BlockPos
import net.minecraftforge.client.event.RenderWorldLastEvent
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import java.lang.Integer.max

/**
 * @author _kisman_
 * @since 20:22 of 12.02.2023
 */
@Suppress("UNUSED_PARAMETER", "NAME_SHADOWING")
@ModuleInfo(
    name = "PacketMineRewrite3",
    display = "PacketMine",
    desc = "pakt mine",
    category = Category.EXPLOIT
)
class PacketMineRewrite3 : ShaderableModule() {
    private val await = register(Setting("Await", this, false))
    private val swing = register(Setting("Swing", this, true))
    private val swap = register(Setting("Swap", this, true))
    private val fast = register(Setting("Fast", this, false))
    private val silent = register(Setting("Silent", this, true))
    private val rotate = register(Setting("Rotate", this, false))
    private val strict = register(Setting("Strict", this, false))
//    private val multibreak = register(Setting("Multi Break", this, false))
    private val multibreak = register(register(SettingGroup(Setting("Multi Break", this))).add(SettingsList("state", Setting("Multi Break", this, false).setTitle("State"), "silent", Setting("Multi Break Silent", this, false).setTitle("Better Silent"))))
    private val rebreak = register(register(SettingGroup(Setting("Rebreak", this))).add(SettingsList("mode", Setting("Rebreak Modes", this, RebreakModes.Manual).setTitle("Modes"), "attempts", Setting("Rebreak Attempts", this, 0.0, -1.0, 10.0, true).setTitle("Attempts"))))

    private val crystals = register(register(SettingGroup(Setting("Crystals", this))).add(SettingsList("state", Setting("Crystals State", this, false).setTitle("State"), "after", Setting("Crystals Starts After", this, 0.95, 0.0, 1.0, false).setTitle("After"))))

    private val rendererGroup = register(SettingGroup(Setting("Renderer", this)))
    private val logic = register(rendererGroup.add(SettingEnum("Logic", this, AABBProgressModifiers.CentredBox)))
    private val pattern = RenderingRewritePattern(this).group(rendererGroup).preInit().init()
    private val easing = EasingsPattern(this).group(rendererGroup).preInit().init()

    private val renderer = SlideRendererPattern()

    private var pos : BlockPos? = null
    /*private var facing : EnumFacing? = null
    private var start = 0L
    private var breaks = 0
    private var rebreaks = -1*/
    private var broke = false

    //Quad(breaks, start, facing!!, rebreaks)
    private var data = Quad(0, 0L, EnumFacing.UP, -1)
    private val queue = mutableMapOf<BlockPos, Quad<Int, Long, EnumFacing, Int>>()
//    private val rebreaks = mutableMapOf<BlockPos, Int>()

    init {
        setDisplayInfo { "[${if(pos == null) "no block no fun" else "${pos!!.x} ${pos!!.y} ${pos!!.z}${if (queue.isEmpty()) "" else " | Queue: ${queue.size}"}"}]" }

        instance = this
    }

    companion object {
        @JvmField var instance : PacketMineRewrite3? = null
    }

    override fun onEnable() {
        super.onEnable()
        Kisman.EVENT_BUS.subscribe(clickBlock)
        Kisman.EVENT_BUS.subscribe(send)

        reset()
    }

    override fun onDisable() {
        super.onDisable()
        Kisman.EVENT_BUS.unsubscribe(clickBlock)
        Kisman.EVENT_BUS.unsubscribe(send)
    }

    override fun update() {
        if(mc.player == null || mc.world == null || pos == null || broke) {
            return
        }

        if(!multibreak["state"].valBoolean && queue.isNotEmpty()) {
            queue.clear()
        }

        val slot = InventoryUtil.findBestToolSlot(pos)

        fun progress(
            pos : BlockPos,
            start : Long,
            slot : Int
        ) : Double = 1 - BlockUtil2.getBreakingProgress(pos, mc.player.inventory.getStackInSlot(slot), start)

        fun swap(
            slot : Int
        ) {
            if(strict.valBoolean) {
                if(mc.currentScreen == null) {
                    InventoryUtil.inventorySwap(slot)
                }
            } else {
                SwapEnum2.Swap.Packet.task.doTask(slot, false)
            }
        }

        fun process0(
            pos : BlockPos,
            data : Quad<Int, Long, EnumFacing, Int>
        ) {
            val progress = progress(pos, data.second, slot)

            if(progress > 0.95 && rotate.valBoolean) {
                RotationSystem.handleRotate(pos)
            }

            if(progress >= 1) {
                val oldSlot = mc.player.inventory.currentItem

                if (swap.valBoolean) {
                    swap(slot)
                }

                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, data.third))
                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, pos, EnumFacing.UP))

                if (fast.valBoolean) {
                    mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, data.third))
                }

                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, data.third))

                if (swap.valBoolean && silent.valBoolean) {
                    swap(
                        if (strict.valBoolean) {
                            slot
                        } else {
                            oldSlot
                        }
                    )
                }

                data.first++
            }
        }

        fun process1(
            pos : BlockPos,
            data : Quad<Int, Long, EnumFacing, Int>,
            remove : (BlockPos) -> Unit
        ) {
            if(data.first > 2 && (rebreak["attempts"].valInt == 0 || data.fourth > rebreak["attempts"].valInt)) {
                remove(pos)
            }
        }

        fun process2(
            pos : BlockPos,
            data : Quad<Int, Long, EnumFacing, Int>
        ) {
            if(block(pos) == Blocks.AIR) {
                data.fourth++
            }
        }

        fun process3(
            pos : BlockPos,
            data : Quad<Int, Long, EnumFacing, Int>
        ) {
            val progress = progress(pos, data.second, slot)

            if(crystals["state"].valBoolean && progress > crystals["after"].valDouble) {
                Crystals.instance!!.pos = pos
            }
        }

        if(pos != null) {
            process0(pos!!, data)
            process1(pos!!, data) { reset() }
            process2(pos!!, data)
            process3(pos!!, data)
        }

        for(entry in HashMap(queue)) {
            val pos = entry.key
            val data = entry.value

            process0(pos, data)
            process1(pos, data) { queue.remove(pos) }
            process2(pos, data)
        }

        /*if(rebreak["attempts"].valInt == 0 && block(pos!!) == Blocks.AIR) {
            reset()
            return
        }*/

        /*if(pos == null || breaks > 2) {
            reset()
            return
        }*/

//        val slot = InventoryUtil.findBestToolSlot(pos)
        /*val progress = progress(pos!!, start, slot)


        if(crystalsState.valBoolean && progress > crystalsStartAfter.valDouble) {
            Crystals.instance!!.pos = pos!!
        }

        fun processBlock(
            pos : BlockPos,
            quad : Quad<Int, Long, EnumFacing, Int>,
            progress : Double,
            remove : (BlockPos) -> Unit
        ) : Int {
            if(block(pos) == Blocks.AIR) {
                if(rebreak["attempts"].valInt == 0) {
                    remove(pos)
                }

                return 0
            }

            if (progress > 0.95) {
                if (rotate.valBoolean) {
                    RotationSystem.handleRotate(pos)
                }
            }

            return if (progress >= 1) {
                val oldSlot = mc.player.inventory.currentItem

                if (swap.valBoolean) {
                    swap(slot)
                }

                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, quad.third))
                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, pos, EnumFacing.UP))

                if (fast.valBoolean) {
                    mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, quad.third))
                }

                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, quad.third))

                if (swap.valBoolean && silent.valBoolean) {
                    swap(
                        if (strict.valBoolean) {
                            slot
                        } else {
                            oldSlot
                        }
                    )
                }

                quad.first + 1
            } else {
                quad.first
            }
        }

        fun rebreak(
            pos : BlockPos,
            rebreaks : Int,
            `true` : (BlockPos, Int) -> Unit,
            `false` : (BlockPos) -> Unit
        ) {
            val attempts = rebreak["attempts"].valInt

            if(attempts == -1) {
                return
            }

            val breaks = max(0, rebreaks)*//*if(quad.fourth == -1) {
                    0
                //rebreaks[pos] ?: 0
                } else {
                    quad.fourth
                }*//*

            if(breaks < attempts) {
                //rebreaks[pos] = breaks + 1
//                quad.fourth = breaks + 1
//                ChatUtility.info().printClientModuleMessage("Rebreaking $pos ${breaks + 1} times!")
                `true`(pos, breaks + 1)
            } else {
//                    rebreaks.remove(pos)
//                queue.remove(pos)
                `false`(pos)
            }
        }

        rebreak(
            pos!!,
            rebreaks,
            { pos, breaks ->
                ChatUtility.info().printClientModuleMessage("Rebreaking $pos $breaks times!")
                rebreaks = breaks
            },
            { reset() }
        )

        breaks = processBlock(pos!!, Quad(breaks, start, facing ?: EnumFacing.UP, rebreaks), progress) { reset() }

        for(entry in HashMap(queue)) {
            val pos = entry.key
            val quad = entry.value

            if(quad.first <= 2) {
                val progress0 = progress(pos, quad.second, slot)

                queue[pos] = Quad(processBlock(pos, quad, progress0) { queue.remove(it) }, quad.second, quad.third, quad.fourth)
            } else {
                rebreak(
                    pos,
                    quad.fourth,
                    { pos, breaks ->
                        ChatUtility.info().printClientModuleMessage("Rebreaking $pos $breaks times!")
                        quad.fourth = breaks
                        quad.first = 0
                    },
                    { pos ->
                        queue.remove(pos)
                    }
                )
                *//*val attempts = rebreak["attempts"].valInt

                if(attempts == -1) {
                    continue
                }

                val breaks = max(0, quad.fourth)*//**//*if(quad.fourth == -1) {
                    0
                //rebreaks[pos] ?: 0
                } else {
                    quad.fourth
                }*//**//*

                if(breaks < attempts) {
                    //rebreaks[pos] = breaks + 1
                    quad.fourth = breaks + 1
                    ChatUtility.info().printClientModuleMessage("Rebreaking $pos ${breaks + 1} times!")
                } else {
//                    rebreaks.remove(pos)
                    queue.remove(pos)
                }*//*
            }
        }*/
    }

    private fun reset() {
//        pos = null
//        data = Quad(0, 0L, EnumFacing.UP, 0)
        data.first = 0
        broke = true
//        facing = null
//        start = 0L
//        breaks = 0
//        rebreaks = -1

        if(crystals["state"].valBoolean) {
            Crystals.instance!!.pos = null
        }
    }

    private val clickBlock = Listener<EventDamageBlock>(EventHook {
        if(await.valBoolean && pos != null && mc.world.getBlockState(pos!!).block != Blocks.AIR) {
            return@EventHook
        }

        if(BlockUtil2.canBlockBeBroken(it.blockPos)) {
            fun processBlock(
                pos : BlockPos,
                facing : EnumFacing
            ) {
                if(swing.valBoolean) {
                    mc.player.swingArm(EnumHand.MAIN_HAND)
                }

                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing))
                mc.player.connection.sendPacket(CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, EnumFacing.UP))
            }

            if(pos != null && multibreak["state"].valBoolean) {
                queue[pos!!] = data
            }

            if(swap.valBoolean && silent.valBoolean && multibreak["silent"].valBoolean) {
                for(entry in queue) {
                    val data = entry.value
                    val pos = entry.key
                    val facing = data.third

                    data.second = System.currentTimeMillis()

                    processBlock(pos, facing)
                }
            }

            val start = System.currentTimeMillis()
            val facing = it.faceDirection

            pos = it.blockPos
            data = Quad(0, start, facing, -1)
            broke = false

            processBlock(pos!!, facing)
        }
    })

    private val send = Listener<PacketEvent.Send>(EventHook {
        val packet = it.packet

        if(packet is CPacketHeldItemChange && strict.valBoolean) {
            reset()
        }
    })

    @SubscribeEvent
    fun onRenderWorld(
        event : RenderWorldLastEvent
    ) {
        handleDraw(pattern)
    }

    override fun draw() {
        fun processBlock(
            pos : BlockPos?,
            start : Long
        ) {
            renderer.handleRenderWorld(
                0f,
                0f,
                0f,
                pattern,
                { it0 ->
                    if (pos != null) {
                        logic.valEnum.modifier.modify(
                            it0,
                            easing.mutateProgress(
                                1 - BlockUtil2.getBreakingProgress(
                                    pos,
                                    mc.player.inventory.getStackInSlot(InventoryUtil.findBestToolSlot(pos)),
                                    start
                                )
                            )
                        )
                    } else {
                        it0
                    }
                },
                pos,
                null
            )
        }

        if(pos != null) {
            val start = data.second

            processBlock(pos, start)
        }

        for(entry in queue) {
            val pos = entry.key
            val quad = entry.value
            val start = quad.second

            processBlock(pos, start)
        }
    }

    fun current() : BlockPos? = pos
    fun queue() : Set<BlockPos> = queue.keys

    enum class RebreakModes {
//        None,
        Manual,
        Instant
    }
}