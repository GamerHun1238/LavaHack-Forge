package com.kisman.cc.features.module.exploit;

import com.kisman.cc.features.module.Category;
import com.kisman.cc.features.module.Module;
import com.kisman.cc.settings.Setting;
import com.kisman.cc.settings.util.RenderingRewritePattern;
import com.kisman.cc.util.entity.EntityUtil;
import com.kisman.cc.util.math.Trigonometric;
import com.kisman.cc.util.render.RenderUtil;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;
import java.util.List;
import java.util.*;
import java.util.stream.Collectors;

public class PlayerLook extends Module {
    private final Setting single = register(new Setting("Single", this, true));
    private final Setting radius = register(new Setting("Radius", this, 5.5, 1.0, 20.0, false));
    private final Setting range = register(new Setting("Range", this, 8.0, 1.0, 15.0, false));
    private final Setting raytrace = register(new Setting("Raytrace", this, true));
    private final Setting displayName = register(new Setting("Display Name", this, false));
    private final RenderingRewritePattern pattern = new RenderingRewritePattern(this).preInit().init();

    public PlayerLook(){
        super("PlayerLook", Category.EXPLOIT);
    }

    @SubscribeEvent
    public void onRender(RenderWorldLastEvent event){
        if(mc.player == null || mc.world == null) return;

        double range = this.range.getValDouble();

        List<Entity> entities;

        if(single.getValBoolean()){
            Entity target = EntityUtil.getTarget((float) range);
            if(target == null)
                return;
            entities = Collections.singletonList(target);
        } else {
            entities = mc.world.loadedEntityList.stream().filter(entity -> entity.getDistanceSq(mc.player) <= (range * range)).collect(Collectors.toList());
        }

        if(entities.isEmpty())
            return;

        HashMap<BlockPos, ArrayList<Entity>> posses = new HashMap<>();

        for(Entity entity : entities) {
            if(entity instanceof EntityItem) continue;

            BlockPos pos = Trigonometric.entityObjectMouseOver(entity, radius.getValDouble(), raytrace.getValBoolean());

            if(pos == null) continue;

            if(posses.containsKey(pos)) {
                posses.get(pos).add(entity);
            } else {
                posses.put(
                        pos,
                        new ArrayList<>(Collections.singletonList(entity))
                );
            }
        }

        for(BlockPos pos : posses.keySet()) {
            pattern.draw(new AxisAlignedBB(pos));

            if(displayName.getValBoolean()) {
                StringBuilder text = new StringBuilder();

                for(
                        int i = 0;
                        i < posses.get(pos).size();
                        i++
                ) {
                    text.append(posses.get(pos).get(i).getName());

                    if(i != posses.get(pos).size() - 1) text.append("\n");
                }

                RenderUtil.drawText(
                        pos,
                        text.toString(),
                        Color.WHITE.getRGB()
                );
            }
        }
    }
}
