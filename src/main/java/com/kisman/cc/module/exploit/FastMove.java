package com.kisman.cc.module.exploit;

import com.kisman.cc.module.Category;
import com.kisman.cc.module.Module;
import com.kisman.cc.settings.Setting;
import com.kisman.cc.util.MotionUtil;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.Vec3d;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class FastMove extends Module {

    private final Setting amount = register(new Setting("Amount", this, 5, 1, 10, true));
    private final Setting distance = register(new Setting("Distance", this, 10, 5, 50, true));
    private final Setting sprint = register(new Setting("Sprint", this, false));
    private final Setting setPos = register(new Setting("SetPosition", this, true));

    public FastMove(){
        super("FastMove", Category.EXPLOIT);
    }

    Queue<List<CPacketPlayer.Position>> queue = new LinkedList<>();

    private boolean prep = true;

    @Override
    public void onEnable(){
        if(mc.player == null || mc.world == null){
            toggle();
            return;
        }
        EnumFacing facing = mc.player.getHorizontalFacing();
        int iterations = distance.getValInt() / amount.getValInt();
        int rem = distance.getValInt() - (iterations * amount.getValInt());
        double lastX = mc.player.posX;
        double lastY = mc.player.posY;
        double lastZ = mc.player.posZ;
        for(int i = 0; i < iterations; i++) {
            Vec3d vec = offset(facing, amount.getValInt(), lastX, lastY, lastZ);
            int ticks = MotionUtil.getTicksUntil(getDistance(lastX, lastY, lastZ, vec.x, vec.y, vec.z), sprint.getValBoolean());
            CPacketPlayer.Position[] packets = MotionUtil.getPacketsTeleport(ticks, true, false, false, false, lastX, lastY, lastZ, vec.x, vec.y, vec.z);
            queue.offer(Arrays.asList(packets));
            lastX = vec.x;
            lastY = vec.y;
            lastZ = vec.z;
        }
        if(rem == 0){
            prep = false;
            return;
        }
        Vec3d vec = offset(facing, amount.getValInt(), lastX, lastY, lastZ);
        int ticks = MotionUtil.getTicksUntil(getDistance(lastX, lastY, lastZ, vec.x, vec.y, vec.z), sprint.getValBoolean());
        CPacketPlayer.Position[] packets = MotionUtil.getPacketsTeleport(ticks, true, false, false, false, lastX, lastY, lastZ, vec.x, vec.y, vec.z);
        queue.offer(Arrays.asList(packets));
        prep = false;
    }

    @Override
    public void update(){
        if(mc.player == null || mc.world == null){
            toggle();
            return;
        }

        if(prep)
            return;

        if(queue.isEmpty()){
            toggle();
            return;
        }

        List<CPacketPlayer.Position> packets = queue.poll();

        for(CPacketPlayer.Position packet : packets){
            if(packet == null)
                continue;
            mc.player.connection.sendPacket(packet);
            if(setPos.getValBoolean())
                mc.player.setPosition(packet.x, packet.y, packet.z);
        }

        if(!queue.isEmpty()) return;

        CPacketPlayer.Position lastPacket = packets.get(packets.size() - 1);
        mc.player.setPosition(lastPacket.x, lastPacket.y, lastPacket.z);
    }

    @Override
    public void onDisable(){
        queue.clear();
        prep = true;
    }

    private double getDistance(double x, double y, double z, double x1, double y1, double z1){
        double dX = x - x1;
        double dY = y - y1;
        double dZ = z - z1;
        return Math.sqrt(dX * dX + dY * dY + dZ * dZ);
    }

    private Vec3d offset(EnumFacing facing, double amount, double x, double y, double z){
        double newX = x;
        double newZ = z;
        switch(facing){
            case NORTH:
                newZ -= amount;
                break;
            case EAST:
                newX += amount;
            case SOUTH:
                newZ += amount;
            case WEST:
                newX -= amount;
            default:
                return new Vec3d(x, y, z);
        }
        return new Vec3d(newX, y, newZ);
    }
}
